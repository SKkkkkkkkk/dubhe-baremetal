#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "FreeRTOS_CLI.h"


static BaseType_t print_helloworld(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
{
	/* For simplicity, this function assumes the output buffer is large enough
    to hold all the text generated by executing the vTaskList() API function,
    so the xWriteBufferLen parameter is not used. */
	(void)xWriteBufferLen;

	/* pcWriteBuffer is used directly as the vTaskList() parameter, so the table
    generated by executing vTaskList() is written directly into the output
    buffer. */
	// vTaskList( pcWriteBuffer + strlen( pcHeader ) );
	strcpy(pcWriteBuffer, "hello world\n\r");

	/* The entire table was written directly to the output buffer.  Execution
    of this command is complete, so return pdFALSE. */
	return pdFALSE;
}

/* This function implements the behaviour of a command, so must have the correct
prototype. */
static BaseType_t prvTaskStatsCommand(char *pcWriteBuffer, size_t xWriteBufferLen, const char *pcCommandString)
{
	/* For simplicity, this function assumes the output buffer is large enough
    to hold all the text generated by executing the vTaskList() API function,
    so the xWriteBufferLen parameter is not used. */
	(void)xWriteBufferLen;

	/* pcWriteBuffer is used directly as the vTaskList() parameter, so the table
    generated by executing vTaskList() is written directly into the output
    buffer. */
	// vTaskList(pcWriteBuffer);
	strcpy(pcWriteBuffer, "hello world1\n\r");

	/* The entire table was written directly to the output buffer.  Execution
    of this command is complete, so return pdFALSE. */
	return pdFALSE;
}

static const CLI_Command_Definition_t CLI_CMD_helloworld = { .pcCommand = "HelloWorld",
								.pcHelpString = "HelloWorld\r\n",
								.pxCommandInterpreter = print_helloworld,
								.cExpectedNumberOfParameters = 0 };

static const CLI_Command_Definition_t CLI_CMD_ShowTaskStats = { .pcCommand = "TaskStats",
								.pcHelpString = "TaskStats\r\n",
								.pxCommandInterpreter = prvTaskStatsCommand,
								.cExpectedNumberOfParameters = 0 };

static CLI_Definition_List_Item_t CLI_CMD_helloworld_Item = {
								.pxCommandLineDefinition = &CLI_CMD_helloworld,
								.pxNext = NULL };

static CLI_Definition_List_Item_t CLI_CMD_ShowTaskStats_Item = {
								.pxCommandLineDefinition = &CLI_CMD_ShowTaskStats,
								.pxNext = NULL };

void CLIRegisterCommand(void)
{
#if defined(configSUPPORT_MALLOC) && (configSUPPORT_MALLOC != 0)
	FreeRTOS_CLIRegisterCommand(&CLI_CMD_helloworld);
	FreeRTOS_CLIRegisterCommand(&CLI_CMD_ShowTaskStats);
#endif
	(void)CLI_CMD_helloworld;
	(void)CLI_CMD_ShowTaskStats;
	FreeRTOS_CLIRegisterCommandStatic(&CLI_CMD_helloworld_Item);
	FreeRTOS_CLIRegisterCommandStatic(&CLI_CMD_ShowTaskStats_Item);
}

void task_cli(void *arg)
{
	printf("this is task cli.\n\r");
	while (1) {
		// FreeRTOS_CLIProcessCommand()
	}
}

#define MAX_INPUT_LENGTH 50
#define MAX_OUTPUT_LENGTH 96

static const char *const pcWelcomeMessage = "Command server.Type Help to view a list of registered commands.";
static char clrline[MAX_INPUT_LENGTH + 1];
void vCommandConsoleTask(void *pvParameters)
{
	// Peripheral_Descriptor_t xConsole;
	int8_t cRxedChar, cInputIndex = 0;
	BaseType_t xMoreDataToFollow;
	/* The input and output buffers are declared static to keep them off the stack. */
	static char pcOutputString[MAX_OUTPUT_LENGTH], pcInputString[MAX_INPUT_LENGTH];

	/* This code assumes the peripheral being used as the console has already
    been opened and configured, and is passed into the task as the task
    parameter.  Cast the task parameter to the correct type. */
	// xConsole = ( Peripheral_Descriptor_t ) pvParameters;

	/* Send a welcome message to the user knows they are connected. */
	// FreeRTOS_write( xConsole, pcWelcomeMessage, strlen( pcWelcomeMessage ) );
	printf("%s\n\r", pcWelcomeMessage);

	memset(clrline, ' ', MAX_INPUT_LENGTH);
	clrline[MAX_INPUT_LENGTH] = 0;

	putchar('>');
	for (;;) 
	{
		cRxedChar = getchar();

		if (cRxedChar == '\r') 
		{
			printf("\n\r");

			if (cInputIndex == 0) 
			{
				putchar('>');
				continue;
			}

			do 
			{
				xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
					pcInputString, /* The command string.*/
					pcOutputString, /* The output buffer. */
					MAX_OUTPUT_LENGTH /* The size of the output buffer. */
				);
				printf("%s", pcOutputString);
			} while (xMoreDataToFollow != pdFALSE);

			cInputIndex = 0;
			memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
			putchar('>');
		}
		else 
		{
			if ((cRxedChar>=32) && (cRxedChar<=126)) // 可显示字符
			{
				if (cInputIndex < MAX_INPUT_LENGTH) 
				{
					pcInputString[cInputIndex] = cRxedChar;
					putchar(cRxedChar);
					cInputIndex++;
				}
			}
			else if ((cRxedChar == '\b') || (cRxedChar == 127)) // 退格&删除
			{
				if (cInputIndex > 0) 
				{
					cInputIndex--;
					pcInputString[cInputIndex] = 0;
					putchar('\b');
					putchar(' ');
					putchar('\b');
				}
			}
			else //不支持的字符
			{

			}
	}
	}
}